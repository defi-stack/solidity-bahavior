# ERC165

## Summary

This is the implementation detail of ERC165, a standard for publishing and detecting what interfaces a smart contract support.

## interface

```solidity
interface IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool);
}

```

## Detail

### interfaceId

An interface ID is a 4-bytes hash generated by function signature. If a contract implements a function, we can calculate the interface ID and get `True` after calling `supportsInterface`.

Take `IERC165` for example, the interface ID can be calculate by the `keccak256`

```solidity
// 0x01ffc9a7
bytes4(keccak256('supportsInterface(bytes4)'))
```

or function selector

```solidity
// 0x01ffc9a7
ERC165.supportsInterface.selector
```

According below, we can create the basic implementation of `ERC165`.

```solidity
contract BasicERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceID) public override view returns (bool) {
        return interfaceID == bytes4(keccak256('supportsInterface(bytes4)'));
    }
}
```

### Add support for other contracts

Take `ERC165Storage` for example.

```solidity
contract ERC165Storage {
    uint32 public data;

    function get() public view returns (uint32) {
        return data;
    }

    function set(uint32 _data) public returns (bool) {
        data = _data;
        return true;
    }
}
```

We should let `ERC165Storage` inherit the interface of `IERC165` and override the `supportsInterface` function.

```solidity
contract ERC165Storage is IERC165 {
    uint32 public data;

    function get() public view returns (uint32) {
        return data;
    }

    function set(uint32 _data) public returns (bool) {
        data = _data;
        return true;
    }

    function supportsInterface(bytes4 interfaceId) public override view returns (bool) {
        return interfaceId == bytes4(keccak256('supportsInterface(bytes4)'));
    }
}
```

Register the `get()` and `set()` interface ID.

```solidity
function supportsInterface(bytes4 interfaceId) public override view returns (bool) {
    return interfaceId == this.supportsInterface.selector ||
        interfaceId == this.get.selector ||
        interfaceId == this.set.selector;
}
```

### Advance

However, it is annoying to add function signature one by one. To solve the situation, we can calculate an ID which combines all the interface IDs. Just XOR them.

```solidity
function supportsInterface(bytes4 interfaceId) public override view returns (bool) {
    return interfaceId == this.supportsInterface.selector ||
        interfaceId == (this.get.selector ^ this.set.selector);
}
```

Since Solidity 0.7.2 you can now write `type(interface_declaration).interfaceId` instead of calculate the xor interface ID. We can declare the interface which inherited by contract.

```solidity
interface IAdvanceStorage {
    function get() external view returns (uint32);
    function set(uint32) external returns (bool);
}
```

After that, the contract can be written to

```solidity
contract ERC165AdvanceStorage is ERC165, IAdvanceStorage {
    uint32 public data;

    function get() public view returns (uint32) {
        return data;
    }

    function set(uint32 _data) public returns (bool) {
        data = _data;
        return true;
    }

    function supportsInterface(bytes4 interfaceId) public override view returns (bool) {
        return interfaceId == this.supportsInterface.selector ||
            interfaceId == type(IAdvanceStorage).interfaceId;
    }
}
```

## Reference

- [https://eips.ethereum.org/EIPS/eip-165](https://eips.ethereum.org/EIPS/eip-165)
- [https://soliditydeveloper.com/eip-165](https://soliditydeveloper.com/eip-165)
